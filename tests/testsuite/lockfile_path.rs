//! Tests for `lockfile-path` flag

use cargo_test_support::paths::CargoPathExt;
use cargo_test_support::{
    basic_bin_manifest, cargo_test, project, symlink_supported, Project, ProjectBuilder,
};
use snapbox::str;
use std::fs;

fn basic_project() -> ProjectBuilder {
    return project()
        .file("Cargo.toml", &basic_bin_manifest("test_foo"))
        .file("src/main.rs", "fn main() {}");
}

fn run_basic_command(p: &Project, command: &str, lockfile_path_argument: &str) {
    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .run();
}

#[track_caller]
fn assert_lockfile_created(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let p = basic_project().build();

    for _ in 1..=2 {
        run_basic_command(&p, command, lockfile_path_argument);
        assert!(p.root().join(lockfile_path_argument).is_file());
        assert!(!p.root().join("Cargo.lock").is_file());
    }

    p.root()
        .join(lockfile_path_argument)
        .parent()
        .unwrap()
        .rm_rf();

    run_basic_command(&p, command, lockfile_path_argument);
    assert!(p.root().join(lockfile_path_argument).is_file());
    assert!(!p.root().join("Cargo.lock").is_file());
}

fn assert_lockfile_override(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let p = basic_project()
        .file("Cargo.lock", "This is an invalid lock file!")
        .build();

    run_basic_command(&p, command, lockfile_path_argument);

    assert!(p.root().join(lockfile_path_argument).is_file());
}

fn assert_symlink_in_path(command: &str) {
    if !symlink_supported() {
        return;
    }

    let dst = "dst";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project().symlink_dir(dst, src).build();

    fs::create_dir(p.root().join("dst"))
        .unwrap_or_else(|e| panic!("could not create directory {}", e));
    assert!(p.root().join(src).is_dir());

    run_basic_command(&p, command, lockfile_path_argument.as_str());

    assert!(p.root().join(format!("{src}/Cargo.lock")).is_file());
    assert!(p.root().join(lockfile_path_argument).is_file());
    assert!(p.root().join(dst).join("Cargo.lock").is_file());
}

fn assert_symlink_lockfile(command: &str) {
    if !symlink_supported() {
        return;
    }

    let lockfile_path_argument = "dst/Cargo.lock";
    let src = "somedir/link";
    let lock_body = r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "test_foo"
version = "0.5.0"
"#;

    let p = basic_project()
        .file(lockfile_path_argument, lock_body)
        .symlink(lockfile_path_argument, src)
        .build();

    assert!(p.root().join(src).is_file());

    run_basic_command(&p, command, lockfile_path_argument);

    assert!(!p.root().join("Cargo.lock").is_file());
}

fn assert_broken_symlink(command: &str) {
    if !symlink_supported() {
        return;
    }

    let invalid_dst = "invalid_path";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project().symlink_dir(invalid_dst, src).build();
    assert!(!p.root().join(src).is_dir());

    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .with_status(101)
        .with_stderr_data(str![[r#"
[ERROR] Failed to create lockfile-path parent directory somedir/link

Caused by:
  File exists (os error 17)

"#]])
        .run();
}

fn assert_loop_symlink(command: &str) {
    if !symlink_supported() {
        return;
    }

    let loop_link = "loop";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project()
        .symlink_dir(loop_link, src)
        .symlink_dir(src, loop_link)
        .build();
    assert!(!p.root().join(src).is_dir());

    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .with_status(101)
        .with_stderr_data(str![[r#"
[ERROR] Failed to fetch lock file's parent path metadata somedir/link

Caused by:
  Too many levels of symbolic links (os error 40)

"#]])
        .run();
}

macro_rules! tests {
    ($name: ident, $command:expr) => {
        #[cfg(test)]
        mod $name {
            use super::*;
        
            #[cargo_test(nightly, reason = "--lockfile-path is unstable")]
            fn test_lockfile_created() {
                assert_lockfile_created($command);
            }
        
            #[cargo_test(nightly, reason = "--lockfile-path is unstable")]
            fn test_lockfile_override() {
                assert_lockfile_override($command);
            }
        
            #[cargo_test(nightly, reason = "--lockfile-path is unstable")]
            fn test_symlink_in_path() {
                assert_symlink_in_path($command);
            }
        
            #[cargo_test(nightly, reason = "--lockfile-path is unstable")]
            fn test_symlink_lockfile() {
                assert_symlink_lockfile($command);
            }
        
            #[cargo_test(nightly, reason = "--lockfile-path is unstable")]
            fn test_broken_symlink() {
                assert_broken_symlink($command);
            }
        
            #[cargo_test(nightly, reason = "--lockfile-path is unstable")]
            fn test_loop_symlink() {
                assert_loop_symlink($command);
            }
        }
    }
}

tests!(add, "add");
tests!(bench, "bench");
tests!(build, "build");
tests!(check, "check");
tests!(clean, "clean");
tests!(doc, "doc");
tests!(fetch, "fetch");
tests!(fix, "fix");
tests!(generate_lockfile, "generate-lockfile");
tests!(locate_project, "locate-project");
tests!(metadata, "metadata");
tests!(package, "package");
tests!(pkgid, "pkgid");
tests!(publish, "publish");
tests!(read_manifest, "read-manifest");
tests!(remove, "remove");
tests!(run, "run");
tests!(rustc, "rustc");
tests!(rustdoc, "rustdoc");
tests!(test, "test");
tests!(tree, "tree");
tests!(update, "update");
tests!(vendor, "vendor");
tests!(verify_project, "verify-project");