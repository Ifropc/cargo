//! Tests for `lockfile-path` flag

use std::fs;

use cargo_test_support::{
    basic_bin_manifest, cargo_test, project, symlink_supported, Project, ProjectBuilder,
};

fn basic_project() -> ProjectBuilder {
    return project()
        .file("Cargo.toml", &basic_bin_manifest("test_foo"))
        .file("src/main.rs", "fn main() {}");
}

fn run_with_path(p: &Project, command: &str, lockfile_path_argument: &str) {
    p.cargo(command)
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .run();
}

#[track_caller]
fn assert_lockfile_created(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let p = basic_project().build();

    run_with_path(&p, command, lockfile_path_argument);

    assert!(!p.root().join("Cargo.lock").is_file());
    assert!(p.root().join(lockfile_path_argument).is_file());
}

fn assert_symlink_in_path(command: &str) {
    if !symlink_supported() {
        return;
    }

    let dst = "dst";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project().symlink_dir(dst, src).build();

    fs::create_dir(p.root().join("dst"))
        .unwrap_or_else(|e| panic!("could not create directory {}", e));
    assert!(p.root().join(src).is_dir());

    run_with_path(&p, command, lockfile_path_argument.as_str());

    assert!(p.root().join(format!("{src}/Cargo.lock")).is_file());
}

fn assert_symlink_lockfile(command: &str) {
    if !symlink_supported() {
        return;
    }

    let lockfile_path_argument = "dst/Cargo.lock";
    let src = "somedir/link";
    let lock_body = r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "test_foo"
version = "0.5.0"
"#;

    let p = basic_project()
        .file(lockfile_path_argument, lock_body)
        .symlink(lockfile_path_argument, src)
        .build();

    assert!(p.root().join(src).is_file());

    run_with_path(&p, command, lockfile_path_argument);

    assert!(!p.root().join("Cargo.lock").is_file());
}

fn assert_broken_symlink(command: &str) {
    if !symlink_supported() {
        return;
    }

    let invalid_dst = "invalid_path";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project().symlink_dir(invalid_dst, src).build();
    assert!(!p.root().join(src).is_dir());

    p.cargo(command)
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .with_status(101)
        .with_stderr_data("TODO")
        .run();
}

fn assert_loop_symlink(command: &str) {
    if !symlink_supported() {
        return;
    }

    let loop_link = "loop";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project()
        .symlink_dir(loop_link, src)
        .symlink_dir(src, loop_link)
        .build();
    assert!(!p.root().join(src).is_dir());

    p.cargo(command)
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .with_status(101)
        .with_stderr_data("TODO")
        .run();
}

fn assert_lockfile_override(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let p = basic_project()
        .file("Cargo.lock", "This is an invalid lock file!")
        .build();

    run_with_path(&p, command, lockfile_path_argument);

    assert!(p.root().join(lockfile_path_argument).is_file());
}

#[cargo_test]
fn metadata_lockfile_created() {
    assert_lockfile_created("metadata");
}

#[cargo_test]
fn metadata_lockfile_override() {
    assert_lockfile_override("metadata");
}

#[cargo_test]
fn metadata_symlink_in_path() {
    assert_symlink_in_path("metadata");
}

#[cargo_test]
fn metadata_symlink_lockfile() {
    assert_symlink_lockfile("metadata");
}

#[cargo_test]
fn metadata_broken_symlink() {
    assert_broken_symlink("metadata");
}

#[cargo_test]
fn metadata_loop_symlink() {
    assert_loop_symlink("metadata");
}
